<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>磁贴</title>
</head>
<style>
    /* 缓动 */
    * {
        perspective: 1000;
        transform-style: preserve-3d;
    }
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;

        /* flexible box弹性布局，子元素的float，clear，vertical-align属性失效 */
        /* align-items:center; */
        /* align-items:定义flex容器内项目侧轴（纵轴）方向的对齐方式 */
        /* justify-content: center; */
        /* justify-content:设置弹性盒子元素在主轴（横轴）方向上的对齐方式 */
        min-height: 100vh;
        min-width: 100vw;
        /* vh:相对于视口的高度，视口被分为100单位的vh */
        background-color: #f3eeea;

        /* background-image: -webkit-linear-gradient(left,
                #22c1c3, #fdbb2d 25%, #22c1c3 50%, #fdbb2d 75%, #22c1c3); */
        /* -webkit-text-fill-color: transparent; */

        
        /* -webkit-background-clip: text;
        -webkit-background-size: 200% 100%;
        -webkit-animation: myGradientChange 4s infinite linear;
        animation: myGradientChange 4s infinite linear; */
        
    }

    .outbox {
        /* display: flex; */
        background: #ccc;

    }

    .Lbox {
        width: 31vh;
        height: 15vh;
        border: 1px solid rgb(255, 255, 255);
        background: rgb(48, 111, 245);
        margin: 0.5vh;
        /* padding: 1vmax; */
    }

    .Lbox:hover {
        /* transform:rotateY(180deg); */

    }

    .Mbox {
        width: 15vh;
        height: 15vh;
        border: 1px solid rgb(255, 255, 255);
        background: rgb(48, 111, 245);
        margin: 0.5vh;
        /* padding: 1vmax; */
    }

    .Mbox:hover {
        transform: rotateY(180deg);
    }

    .rotateY180{
        transform: rotateY(180deg);
    }
    .rotateY360{
        transform: rotateY(360deg);
    }

    .Sbox {
        width: 7vh;
        height: 7vh;
        border: 1px solid rgb(255, 255, 255);
        background: rgb(48, 111, 245);
        margin: 0.5vh;
        /* padding: 1vmax; */
    }

    .box {
        cursor: move;
        color: #fff;
        text-align: center;
        padding: 0;
        background: rgba(0, 133, 185, 1);
        /* background: linear-gradient(
            290deg,
            rgba(0, 133, 185, 0.37) 0%,
            rgba(48, 111, 245, 1) 100%
        ); */
        /* box-sizing: border-box; */
        box-sizing: border-box;
        /* 暂时为空，1像素边距 */
        border: none;
        /* border: 4px solid red; */
        border: 2px solid transparent;

        /* 为了让图画翻转时不露出背面 */
        /* backface-visibility: hidden; */

        /* 不可选择 */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;

        transition: all 0.25s;
        -webkit-transition: all 0.25s;

        /* 配合翻转，原理我也不懂 */
        /* perspective: 1000;
        transform-style: preserve-3d; */

    }

    .box:hover {
        border: 2px solid rgb(255, 255, 255);

        box-shadow: 0px 0px 15px 1px rgb(80, 80, 80);
        transition: all 1s;
        -webkit-transition: all 1s;
    }

    .box:before {
    }

    .front {
        position: absolute;
        top: 0px;
        left: 0px; 
        background: rgb(25, 172, 98);
        height: 100%;
        text-align:center;
        width: 100%;
        backface-visibility: hidden;
    }
    .front:hover{
    }

    .back {
        position: absolute;
        top: 0px;
        left: 0px;
        backface-visibility: hidden;
        background: #f03e3e;
        display: block;
        height: 100%;
        width: 100%;
        transform: rotateY(-180deg); 
    }

    h1 {
        background-image: -webkit-linear-gradient(left,
                #22c1c3, #fdbb2d 25%, #22c1c3 50%, #fdbb2d 75%, #22c1c3);
        -webkit-text-fill-color: transparent;
        /*规定背景的绘制区域*/
        -webkit-background-clip: text;
        -webkit-background-size: 200% 100%;
        -webkit-animation: myGradientChange 4s infinite linear;
        animation: myGradientChange 4s infinite linear;
    }

    .description,
    .card h2 {
        background-image: -webkit-linear-gradient(left,
                #fdbb2d, #22c1c3 25%, #fdbb2d 50%, #22c1c3 75%, #fdbb2d);
        -webkit-text-fill-color: transparent;
        -webkit-background-clip: text;
        -webkit-background-size: 200% 100%;
        -webkit-animation: myGradientChange 4s infinite linear;
        animation: myGradientChange 4s infinite linear;
    }

    @keyframes myGradientChange {
        0% {
            background-position: 0 0;
        }

        100% {
            background-position: -100% 0;
        }
    }
</style>

<body>
    <div class="outbox">
        <div class="Lbox box">L</div>
        <div id="Mbox" class="Mbox box">
            <div class="front">
                正面
            </div> 
            <div class="back">
                反面
            </div>
        </div>
        <div class="Mbox box">M</div>
        <div class="Sbox box">S</div>
        <div class="Sbox box">S</div>
        <div class="Sbox box">S</div>
        <div class="Sbox box">S</div>
        <div class="Lbox box">L</div>
        <div id="Mbox" class="Mbox box">M</div>
        <div class="Mbox box">M</div>
        <div class="Sbox box">S</div>
        <div class="Sbox box">S</div>
        <div class="Sbox box">S</div>
        <div class="Sbox box">S</div>
        <div class="Lbox box">L</div>
        <div id="Mbox" class="Mbox box">M</div>
        <div class="Mbox box">M</div>
        <div class="Sbox box">S</div>
        <div class="Sbox box">S</div>
        <div class="Sbox box">S</div>
        <div class="Sbox box">S</div>
    </div>
</body>
<script>
    //margin会出现小数的计算，需要统一 

    var boxer = function () {
        return new boxer.prototype.init();
    };
    boxer.prototype = {
        init: function () {
            console.log("init boxer");

            this.len = 0;
            this.list = [];
            this.index = 0;
            this.zIndex = "10";
            this.word = "";
            this.width = 0;
            this.height = 0;
            this.oldtop = 0;
            this.oldleft = 0;
            this.leftIndex = 0;
            this.topIndex = 0;
            this.SBoxOffsetWidth = 0;
            this.defineSboxClassName = "Sbox";
            this.defineMboxClassName = "Mbox";
            this.defineLboxClassName = "Lbox";

            this.freedomBoxX = 0;
            this.freedomBoxY = 0;

            this.update = function () {

            };
            this.reload = function () {
                this.reloading = true;
                if (this.len != 0) {
                    console.log("reload");
                    if (this.SBoxOffsetWidth != 0) {
                        for (var i = 0; i < this.len; i++) {
                            var el = this.list[i];
                            el.style.zIndex = this.zIndex;
                            var className = el.className;
                            var time = 16;
                            if (className.indexOf(this.defineSboxClassName) != -1) {
                                el.style.width = this.SBoxOffsetWidth + "px";
                                el.style.height = el.style.lineHeight = this.SBoxOffsetWidth + "px";
                                el.style.margin = this.margin + "px";
                            }
                            //这里不对
                            if (className.indexOf(this.defineMboxClassName) != -1) {
                                el.style.width = (this.SBoxOffsetWidth + (this.margin * 2)) * 2 - (2 * this.margin) + "px";
                                el.style.height = el.style.lineHeight = el.style.width;
                                el.style.margin = this.margin + "px";
                            }
                            //这里不对
                            if (className.indexOf(this.defineLboxClassName) != -1) {
                                el.style.width = (this.SBoxOffsetWidth + (this.margin * 2)) * 4 - (2 * this.margin) + "px";
                                el.style.height = el.style.lineHeight = (this.SBoxOffsetWidth + (this.margin * 2)) * 2 - (2 * this.margin) + "px";
                                el.style.margin = this.margin + "px";
                            }
                        }
                    }
                }
                this.reloading = false;
                return this;
            };
            // 计算是否大于最大的index
            this.calLeftIndex = function (leftIndex) {
                var width = this.width;
                var margin = this.margin;
                //console.log(this.maxIndex);
                if (leftIndex > this.maxIndex) {
                    return false;
                }
                return true;
            },
                this.autoArrange = function () {
                    this.autoing = true;
                    //默认从左到右水平排
                    console.log("autoArrange");
                    var topIndex = 0;
                    var leftIndex = 0;
                    this.freedomBoxY = 0;
                    this.freedomBoxX = 0;
                    if (this.len != 0) {
                        if (this.SBoxOffsetWidth != 0) {
                            for (var i = 0; i < this.len; i++) {
                                var el = this.list[i];
                                var className = el.className;
                                //小的磁贴
                                if (className.indexOf(this.defineSboxClassName) != -1) {

                                    //计算是否大于最大的index
                                    if (!this.calLeftIndex(leftIndex + 1)) {
                                        topIndex = this.freedomBoxY;
                                        leftIndex = 0;
                                    };

                                    el.topIndex = topIndex;
                                    el.leftIndex = leftIndex;

                                    el.style.position = 'absolute';

                                    var magrin = this.margin;

                                    el.style.top = topIndex * (this.SBoxOffsetWidth + margin * 2) + "px";
                                    el.style.left = leftIndex * (this.SBoxOffsetWidth + margin * 2) + "px";

                                    leftIndex++;

                                    if (this.freedomBoxY < (topIndex + 1)) {
                                        this.freedomBoxY = topIndex + 1;
                                    }

                                    if (this.freedomBoxX <= leftIndex) {
                                        this.freedomBoxX = leftIndex + 1;
                                    }
                                }
                                //中的磁贴
                                if (className.indexOf(this.defineMboxClassName) != -1) {
                                    //计算是否大于最大的index
                                    if (!this.calLeftIndex(leftIndex + 2)) {

                                        console.log(this.freedomBoxY);
                                        topIndex = this.freedomBoxY;
                                        leftIndex = 0;
                                    };

                                    el.topIndex = topIndex;
                                    el.leftIndex = leftIndex;

                                    el.style.position = 'absolute';

                                    var magrin = this.margin;

                                    el.style.top = topIndex * (this.SBoxOffsetWidth + margin * 2) + "px";
                                    el.style.left = leftIndex * (this.SBoxOffsetWidth + margin * 2) + "px";
                                    //console.log(this.SBoxOffsetWidth);
                                    leftIndex = leftIndex + 2;
                                    if (this.freedomBoxY < (topIndex + 2)) {
                                        this.freedomBoxY = topIndex + 2;
                                    }
                                    if (this.freedomBoxX <= leftIndex) {
                                        this.freedomBoxX = leftIndex + 2;
                                    }
                                }
                                //大的磁贴
                                if (className.indexOf(this.defineLboxClassName) != -1) {
                                    //计算是否大于最大的index
                                    if (!this.calLeftIndex(leftIndex + 4)) {

                                        console.log(this.freedomBoxY);
                                        topIndex = this.freedomBoxY;
                                        leftIndex = 0;
                                    };

                                    el.topIndex = topIndex;
                                    el.leftIndex = leftIndex;

                                    el.style.position = 'absolute';

                                    var margin = this.margin;

                                    el.style.top = topIndex * (this.SBoxOffsetWidth + margin * 2) + "px";
                                    el.style.left = leftIndex * (this.SBoxOffsetWidth + margin * 2) + "px";
                                    //console.log(this.SBoxOffsetWidth);
                                    leftIndex = leftIndex + 4;
                                    if (this.freedomBoxY < (topIndex + 2)) {
                                        this.freedomBoxY = topIndex + 2;
                                    }
                                    if (this.freedomBoxX <= leftIndex) {
                                        this.freedomBoxX = leftIndex + 4;
                                    }
                                }
                            }
                        }

                    }
                    this.autoing = false;
                    return this;
                };
            this.scan = function (str) {
                this.word = str;
                this.list = document.querySelectorAll(str);
                this.len = this.list.length;
                return this;
            };
            this.addmoveaction = function () {
                for (var i = 0; i < this.len; i++) {
                    (function (i, that) {
                        var el = that.list[i];
                        var computedStyle = getComputedStyle(el);
                        var margin = that.margin;
                        el.topIndex = Math.floor(el.offsetTop / (el.offsetHeight + margin * 2));
                        el.leftIndex = Math.floor(el.offsetLeft / (el.offsetWidth + margin * 2));
                        el.onmouseover = function () {
                            el.style.transition = "all 1s";
                            el.style.WebkitTransition = "all 1s";
                            el.style.zIndex = '999';
                        }
                        el.onmouseout = function () {
                            el.style.transition = "all 0.25s";
                            el.style.WebkitTransition = "all 0.25s";
                            el.style.zIndex = that.zIndex;
                        }
                        //添加对象鼠标按下触发事件
                        el.ontouchstart = el.onmousedown = function (e) {
                            var e = e || window.event;
                            //that.consoleLogElInfo(el);

                            //获取按下鼠标到div left  top的距离
                            var disX = e.clientX - this.offsetLeft;
                            var disY = e.clientY - this.offsetTop;

                            //记录坐标
                            el.oldleft = this.offsetLeft;
                            el.oldtop = this.offsetTop;

                            el.style.transition = "";
                            el.style.WebkitTransition = "";

                            //添加鼠标按下移动事件
                            document.ontouchmove = document.onmousemove = function (e) {
                                var e = e || window.event;
                                el.style.position = 'absolute';
                                el.style.transition = "all 0s";
                                el.style.WebkitTransition = "all 0s";
                                el.style.left = (e.clientX - disX - margin) + 'px';
                                el.style.top = (e.clientY - disY - margin) + 'px';
                                el.style.zIndex = '999';
                            };
                            //添加鼠标抬起事件
                            document.ontouchend = document.onmouseup = function (e) {
                                el.style.transition = "all 0.25s";
                                el.style.WebkitTransition = "all 0.25s";

                                el.style.zIndex = that.zIndex;
                                //检测碰撞或包含
                                if (that.checkcollide(el)) {
                                    //碰撞
                                    //重新计算并恢复移动前的坐标
                                    el.style.top = (el.topIndex * (that.SBoxOffsetWidth + margin * 2)) + 'px';
                                    el.style.left = (el.leftIndex * (that.SBoxOffsetWidth + margin * 2)) + 'px';

                                } else {
                                    //未碰撞
                                    that.checkposition(el);
                                }

                                //清空事件
                                document.onmousemove = null;
                                document.onmouseup = null;
                            };
                            //阻止默认事件
                            return false;
                        };
                    })(i, this)
                }
                return this;
            };
            this.checkposition = function (el) {
                //获取对象的最终显示样式
                var computedStyle = getComputedStyle(el);
                //获取对象的margin长度
                var margin = this.margin;

                var clientWidth = el.clientWidth;
                var clientHeight = el.clientHeight;
                var offsetWidth = el.offsetWidth;
                var offsetHeight = el.offsetHeight;
                var offsetTop = el.offsetTop;
                var offsetLeft = el.offsetLeft;
                var SBoxOffsetWidth = this.SBoxOffsetWidth;

                var maxTop = Math.floor((SBoxOffsetWidth + margin * 2));
                var topIndex = Math.floor(offsetTop / (SBoxOffsetWidth + margin * 2));
                //纵轴坐标计算
                var topTmp = offsetTop % (SBoxOffsetWidth + margin * 2);
                if (topTmp > (0.5 * (SBoxOffsetWidth + margin * 2))) {
                    topIndex++;
                }
                if (topIndex < 0) {
                    topIndex = 0;
                }
                el.style.top = (topIndex * (SBoxOffsetWidth + margin * 2)) + 'px';
                //横轴坐标计算
                var leftIndex = Math.floor(offsetLeft / (SBoxOffsetWidth + margin * 2));
                var leftTmp = offsetLeft % (SBoxOffsetWidth + margin * 2);
                if (leftTmp > (0.5 * (SBoxOffsetWidth + margin * 2))) {
                    leftIndex++;
                }
                if (leftIndex < 0) {
                    leftIndex = 0;
                }
                el.style.left = (leftIndex * (SBoxOffsetWidth + margin * 2)) + 'px';

                //检测碰撞或包含
                if (this.checkcollide(el)) {
                    //再次碰撞
                    //再次恢复
                    var computedStyle = getComputedStyle(el);
                    var margin = this.margin;

                    el.style.top = (el.topIndex * (el.offsetHeight + margin * 2)) + 'px';
                    el.style.left = (el.leftIndex * (el.offsetWidth + margin * 2)) + 'px';

                } else {
                    //最终确认对象坐标发生改变
                    //对象元素自身记录新的坐标信息
                    el.oldleft = el.style.left;
                    el.oldtop = el.style.top;
                    el.leftIndex = leftIndex;
                    el.topIndex = topIndex;
                }
            };
            //检测是否发生元素间的碰撞
            this.checkcollide = function (el) {
                for (var i = 0; i < this.len; i++) {
                    var item = this.list[i];
                    if (item != el) {
                        if (this.calculateCollide(el, item)) {
                            console.log("collide");
                            return true;
                        }
                    }
                }
                return false;
            };
            //计算两个元素是由存在重合的区域
            this.calculateCollide = function (el, item) {
                if (!(el.offsetLeft > (item.offsetLeft + item.offsetWidth)
                    || el.offsetTop > (item.offsetTop + item.offsetHeight)
                    || (el.offsetTop + el.offsetHeight) < (item.offsetTop)
                    || (el.offsetLeft + el.offsetWidth) < (item.offsetLeft)
                )) {
                    //碰撞
                    return true;
                }
                return false;
            };
            //打印显示对象大小信息
            this.consoleLogElInfo = function (el) {
                var computedStyle = getComputedStyle(el);
                var margin = parseInt(computedStyle.margin.substring(0, computedStyle.margin.length - 2));
                var border = computedStyle.border;
                console.log("margin:" + margin);
                console.log("border:" + border);
            };
            this.addActionClass = function(){
                for (var i = 0; i < this.len; i++) {
                    var el = this.list[i];
                    addClass(el,"rotateY180");
                }
            },
            this.aaa = function () {

            }
            //
            this.aaa();
            this.getMaxWidthHeight();
            this.calMapIndex();

            return this;
        },
        //获取容器的大小
        getMaxWidthHeight: function () {
            var outboxs = document.getElementsByClassName("outbox");
            var Sbox = document.getElementsByClassName("Sbox");
            if (Sbox.length == 0) {
                var div = document.createElement("div");
                div.className = "Sbox box";
                outboxs[0].appendChild(div);
                this.SBoxOffsetWidth = div.offsetWidth;
                var computedStyle = getComputedStyle(div);
                this.rMargin = computedStyle.margin.substring(0, computedStyle.margin.length - 2);
                this.margin = parseInt(computedStyle.margin.substring(0, computedStyle.margin.length - 2));
                console.log(this.SBoxOffsetWidth);
                console.log(this.margin);
                outboxs[0].removeChild(div);
            }
            if (outboxs.length > 0) {
                this.width = outboxs[0].offsetWidth;
                this.height = outboxs[0].offsetHeight;
                //设置最小单位长度
                this.SBoxOffsetWidth = Sbox[0].offsetWidth;
                //不取整
                //var margin = this.SBoxOffsetWidth/3;
                //记录最小单位margin(取整)
                var computedStyle = getComputedStyle(Sbox[0]);
                this.rMargin = computedStyle.margin.substring(0, computedStyle.margin.length - 2);
                this.margin = parseInt(computedStyle.margin.substring(0, computedStyle.margin.length - 2));
                console.log(this.SBoxOffsetWidth);
                console.log(this.margin);
            }
        },
        calMapIndex: function () {
            console.log("calMapIndex");
            var width = this.width;
            var margin = this.margin;
            //var margin = this.SBoxOffsetWidth/3;//纠结
            this.maxIndex = parseInt(width / (this.SBoxOffsetWidth + margin * 2));
        }
    }
    //如果我在boxer.prototype上扩展方法,确保实例能够调用.
    boxer.prototype.init.prototype = boxer.prototype;
    var boxer = boxer();
    boxer.scan(".box").reload().addmoveaction().autoArrange().addActionClass();

    window.onresize = function () {
        //console.log("resize");
        if (!this.autoing && !this.reloading) {
            boxer.getMaxWidthHeight();
            boxer.calMapIndex();
            boxer.reload();
        }

        boxer.autoArrange();
    }


function addClass(obj, cls){
  var obj_class = obj.className,//获取 class 内容.
  blank = (obj_class != '') ? ' ' : '';//判断获取到的 class 是否为空, 如果不为空在前面加个'空格'.
  added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class.
  obj.className = added;//替换原来的 class.
}
   
function removeClass(obj, cls){
  var obj_class = ' '+obj.className+' ';//获取 class 内容, 并在首尾各加一个空格. ex) 'abc    bcd' -> ' abc    bcd '
  obj_class = obj_class.replace(/(\s+)/gi, ' '),//将多余的空字符替换成一个空格. ex) ' abc    bcd ' -> ' abc bcd '
  removed = obj_class.replace(' '+cls+' ', ' ');//在原来的 class 替换掉首尾加了空格的 class. ex) ' abc bcd ' -> 'bcd '
  removed = removed.replace(/(^\s+)|(\s+$)/g, '');//去掉首尾空格. ex) 'bcd ' -> 'bcd'
  obj.className = removed;//替换原来的 class.
}
   
function hasClass(obj, cls){
  var obj_class = obj.className,//获取 class 内容.
  obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组.
  x = 0;
  for(x in obj_class_lst) {
    if(obj_class_lst[x] == cls) {//循环数组, 判断是否包含cls
      return true;
    }
  }
  return false;
}

</script>

</html>